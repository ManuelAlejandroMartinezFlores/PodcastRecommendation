{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PodcastRecommendation 0.1.8 Podcast Recommendation Algorithm Instalar python3 -m pip install podcast-recommendation pip install podcast-recommendation pip install podcast-recommendation==0.1.8 Uso Import from podcast_recommendation.algorithm import PodcastRecommendation Crear objeto Para utilizarlo debe tener una DataBase abierta en Neo4j con el plugin de Data Science pr = PodcastRecommendation('bolt://localhost:7687', ('neo4j', 'password'), verbose=True) Reading x_train Reading y_train Training model Training complete Generar grafo pr.build_graph(verbose=True) Reading categories Reading ratings Creating categories, categories and IsA Creating users, categories and ratings Build complete Se genera un grafo como el siguiente: Generar recomendaciones Para recomendar podcast al usuario 6C561484AED5C02 pr.recommend(user_id='6C561484AED5C02') proba title 47 0.999225 Noah Kagan Presents 31 0.999216 The Model Health Show 30 0.999042 Mind Pump: Raw Fitness Truth 42 0.999038 Jocko Podcast 43 0.998779 The Learning Leader Show With Ryan Hawk 32 0.998615 Ben Greenfield Fitness ... Eliminar el grafo pr.delete_all() Eliminar rating Eliminar rating entre usuario 6C561484AED5C02 y podcast a3a535f66c7e8004e7dc54c2b2829a9e pr.delete_rtg(user_id='6C561484AED5C02', podcast_id='a3a535f66c7e8004e7dc54c2b2829a9e') Crear rating Crear rating de 5 entre usuario 6C561484AED5C02 y podcast a3a535f66c7e8004e7dc54c2b2829a9e pr.create_rtg(user_id='6C561484AED5C02', podcast_id='a3a535f66c7e8004e7dc54c2b2829a9e', rating=5) Crear usuario Crear usuario de id A1A1A1A1A1A1A1 pr.create_user(user_id='A1A1A1A1A1A1A1') Crear podcast Crear podcast de id a1a1a1a1a1a1a1a1a1a1a1 y t\u00edtulo prueba pr.create_podcast(podcast_id='a1a1a1a1a1a1a1a1a1a1a1', title='prueba') Crear categoria Crear categoria de nombre cat e id 99 pr.create_category(category='cat', category_id=99) Crear relaci\u00f3n IsA Crear relaci\u00f3n podcast de id a1a1a1a1a1a1a1a1a1a1a1 IsA categoria de nombre cat pr.create_IsA(podcast_id='a1a1a1a1a1a1a1a1a1a1a1', category='cat') Cerrar driver pr.close()","title":"Home"},{"location":"#podcastrecommendation","text":"","title":"PodcastRecommendation"},{"location":"#018","text":"Podcast Recommendation Algorithm","title":"0.1.8"},{"location":"#instalar","text":"python3 -m pip install podcast-recommendation pip install podcast-recommendation pip install podcast-recommendation==0.1.8","title":"Instalar"},{"location":"#uso","text":"","title":"Uso"},{"location":"#import","text":"from podcast_recommendation.algorithm import PodcastRecommendation","title":"Import"},{"location":"#crear-objeto","text":"Para utilizarlo debe tener una DataBase abierta en Neo4j con el plugin de Data Science pr = PodcastRecommendation('bolt://localhost:7687', ('neo4j', 'password'), verbose=True) Reading x_train Reading y_train Training model Training complete","title":"Crear objeto"},{"location":"#generar-grafo","text":"pr.build_graph(verbose=True) Reading categories Reading ratings Creating categories, categories and IsA Creating users, categories and ratings Build complete Se genera un grafo como el siguiente:","title":"Generar grafo"},{"location":"#generar-recomendaciones","text":"Para recomendar podcast al usuario 6C561484AED5C02 pr.recommend(user_id='6C561484AED5C02') proba title 47 0.999225 Noah Kagan Presents 31 0.999216 The Model Health Show 30 0.999042 Mind Pump: Raw Fitness Truth 42 0.999038 Jocko Podcast 43 0.998779 The Learning Leader Show With Ryan Hawk 32 0.998615 Ben Greenfield Fitness ...","title":"Generar recomendaciones"},{"location":"#eliminar-el-grafo","text":"pr.delete_all()","title":"Eliminar el grafo"},{"location":"#eliminar-rating","text":"Eliminar rating entre usuario 6C561484AED5C02 y podcast a3a535f66c7e8004e7dc54c2b2829a9e pr.delete_rtg(user_id='6C561484AED5C02', podcast_id='a3a535f66c7e8004e7dc54c2b2829a9e')","title":"Eliminar rating"},{"location":"#crear-rating","text":"Crear rating de 5 entre usuario 6C561484AED5C02 y podcast a3a535f66c7e8004e7dc54c2b2829a9e pr.create_rtg(user_id='6C561484AED5C02', podcast_id='a3a535f66c7e8004e7dc54c2b2829a9e', rating=5)","title":"Crear rating"},{"location":"#crear-usuario","text":"Crear usuario de id A1A1A1A1A1A1A1 pr.create_user(user_id='A1A1A1A1A1A1A1')","title":"Crear usuario"},{"location":"#crear-podcast","text":"Crear podcast de id a1a1a1a1a1a1a1a1a1a1a1 y t\u00edtulo prueba pr.create_podcast(podcast_id='a1a1a1a1a1a1a1a1a1a1a1', title='prueba')","title":"Crear podcast"},{"location":"#crear-categoria","text":"Crear categoria de nombre cat e id 99 pr.create_category(category='cat', category_id=99)","title":"Crear categoria"},{"location":"#crear-relacion-isa","text":"Crear relaci\u00f3n podcast de id a1a1a1a1a1a1a1a1a1a1a1 IsA categoria de nombre cat pr.create_IsA(podcast_id='a1a1a1a1a1a1a1a1a1a1a1', category='cat')","title":"Crear relaci\u00f3n IsA"},{"location":"#cerrar-driver","text":"pr.close()","title":"Cerrar driver"},{"location":"algorithm-reference/","text":"Algorithm module PodcastRecommendation Source code in podcast_recommendation/algorithm.py class PodcastRecommendation : def __init__ ( self , uri : str , auth : str , x_path : str = None , y_path : str = None , verbose : bool = False ) -> None : \"\"\"Creates object. Reads files to train Logistic Regression model. Args: uri (str): neo4j uri auth (str): neo4j (user, psw) x_path (str, optional): path to x_train. Defaults to X_PATH. y_path (str, optional): path to y_train. Defaults to Y_PATH. verbose (bool, optional): verbose. Defaults to False. \"\"\" if x_path is None : x_path = X_PATH if y_path is None : y_path = Y_PATH self . driver = GD . driver ( uri , auth = auth ) self . features = [ 'cat_based' , 'cat_cnt' , 'user_based' , 'user_cnt' , 'adamic_adar' , 'resource_allocation' , 'link_cnt' , 'cat_avg' , 'user_avg' , 'adar_avg' , 'ra_avg' ] self . lr = LogisticRegression ( solver = 'liblinear' , C = 0.5 ) if verbose : print ( \"Reading x_train\" ) X = pd . read_csv ( x_path ) if verbose : print ( \"Reading y_train\" ) Y = pd . read_csv ( y_path ) if verbose : print ( \"Training model\" ) self . lr . fit ( X [ self . features ], Y . values . reshape ( 1 , - 1 )[ 0 ]) if verbose : print ( \"Training complete\" ) if verbose : print ( \"Reading podcasts\" ) self . pod = pd . read_csv ( POD_PATH ) def build_graph ( self , cat_path : str = None , rtg_path : str = None , delete_all : bool = True , verbose : bool = False ) -> None : \"\"\"Builds graph in neo4j Args: cat_path (str, optional): path to categories_sample. Defaults to CAT_PATH. rtg_path (str, optional): path to ratings_sample. Defaults to RTG_PATH. delete_all (bool, optional): if to delete graph before writting. Defaults to True. verbose (bool, optional): verbose. Defaults to False. \"\"\" if cat_path is None : cat_path = CAT_PATH if rtg_path is None : rtg_path = RTG_PATH if delete_all : if verbose : print ( \"Deleting all nodes and relationships\" ) self . delete_all () if verbose : print ( \"Reading categories\" ) cat = pd . read_csv ( cat_path ) if verbose : print ( \"Reading ratings\" ) rtg = pd . read_csv ( rtg_path ) if verbose : print ( \"Creating podcasts, categories and IsA\" ) cat . apply ( self . build_cat , axis = 1 ) if verbose : print ( \"Creating users, categories and ratings\" ) rtg . apply ( self . build_rtg , axis = 1 ) if verbose : print ( \"Build complete\" ) def build_cat ( self , row : pd . Series ) -> None : \"\"\"Builds relations in categories_sample dataset Args: row (pd.Series): dataframe row \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __build_cat , row [ 'category' ], row [ 'category_id' ], row [ 'podcast_id' ]) @staticmethod def __build_cat ( tx , category : str , category_id : str , podcast_id : str ) -> None : \"\"\"Helper for build_cat Args: tx (_type_): transaction category (str): category name category_id (str): category id podcast_id (str): podcast id \"\"\" query = ( \"MERGE (p:Podcast{id: $podcast_id}) \" \"MERGE (c:Category{id: toInteger($category_id), name: $category}) \" \"MERGE (p)-[r:IsA]->(c) \" ) tx . run ( query , podcast_id = podcast_id , category_id = category_id , category = category ) def build_rtg ( self , row : pd . Series ) -> None : \"\"\"Builds relations in ratings_sample dataset Args: row (pd.Series): dataframe row \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __build_rtg , row [ 'user_id' ], row [ 'podcast_id' ], row [ 'rating' ]) @staticmethod def __build_rtg ( tx , user_id : str , podcast_id : str , rating : int ) -> None : \"\"\"Helper for build_rtg Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id rating (int): rating \"\"\" query = ( \"MERGE (u:User{id: $user_id}) \" \"MERGE (p:Podcast{id: $podcast_id}) \" \"MERGE (u)-[r:Rating{rating: toInteger($rating)}]->(p) \" ) tx . run ( query , user_id = user_id , podcast_id = podcast_id , rating = rating ) def close ( self ) -> None : \"\"\"Closes driver. \"\"\" self . driver . close () def delete_all ( self ) -> None : \"\"\"Deletes all elements in the graph \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_all ) @staticmethod def __delete_all ( tx ) -> None : \"\"\"Helper for delete all Args: tx (_type_): transaction \"\"\" query = \"MATCH (m)-[r]->(n) DELETE m, n, r\" tx . run ( query ) def recommend ( self , user_id : str ) -> pd . DataFrame : \"\"\"Generates podcast recommendation for user Args: user_id (str): user id Returns: pd.DataFrame: podcasts and probabilities \"\"\" df = self . gen_df ( user_id ) df = self . gen_data ( df ) df [ 'proba' ] = self . lr . predict_proba ( df [ self . features ])[:, 1 ] df = df . sort_values ( by = 'proba' , ascending = False ) pod = self . pod . copy () . set_index ( 'podcast_id' ) df [ 'title' ] = df [ 'podcast_id' ] . map ( pod [ 'title' ]) return df [[ 'proba' , 'title' ]] def gen_data ( self , df : pd . DataFrame ) -> pd . DataFrame : \"\"\"Generates data for podcast recommendation Args: df (pd.DataFrame): podcasts Returns: pd.DataFrame: dataframe with attributes \"\"\" c_names = [ 'cat_based' , 'cat_cnt' , 'user_based' , 'user_cnt' , 'adamic_adar' , 'resource_allocation' , 'link_cnt' ] df [ c_names ] = df . apply ( self . gen_data_row , axis = 1 , result_type = 'expand' ) df [ 'cat_avg' ] = df [ 'cat_based' ] / df [ 'cat_cnt' ] df [ 'user_avg' ] = df [ 'user_based' ] / df [ 'user_cnt' ] df [ 'adar_avg' ] = df [ 'adamic_adar' ] / df [ 'link_cnt' ] df [ 'ra_avg' ] = df [ 'resource_allocation' ] / df [ 'link_cnt' ] df = df . fillna ( 0 ) return df def gen_data_row ( self , row : pd . Series ) -> list : \"\"\"Helper for gen_data Args: row (pd.Series): row of data Returns: list: list of attributes \"\"\" u_id , p_id = row [ 'user_id' ], row [ 'podcast_id' ] result = self . get_cat_based ( u_id , p_id ) result += self . get_user_based ( u_id , p_id ) result += self . adamic_adar ( u_id , p_id ) result += self . resource_allocation ( u_id , p_id ) return result def delete_rtg ( self , user_id : str , podcast_id : str ) -> None : \"\"\"Deletes rating relationship Args: user_id (str): user id podcast_id (str): podcast id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_rtg , user_id , podcast_id ) @staticmethod def __delete_rtg ( tx , user_id : str , podcast_id : str ) -> None : \"\"\"Helper for delete_rtg Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id \"\"\" query = ( \"MATCH (u:User)-[r]->(p:Podcast) \" \"WHERE u.id = $user_id AND p.id = $podcast_id \" \"DELETE r\" ) tx . run ( query , user_id = user_id , podcast_id = podcast_id ) def create_rtg ( self , user_id : str , podcast_id : str , rating : int ) -> None : \"\"\"Create rating relationship Args: user_id (str): user id podcast_id (str): podcast id rating (int): rating \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_rtg , user_id , podcast_id , rating ) @staticmethod def __create_rtg ( tx , user_id : str , podcast_id : str , rating : int ) -> None : \"\"\"Helper for create_rtg Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id rating (int): rating \"\"\" query = ( \"MATCH (u:User) MATCH (p:Podcast) \" \"WHERE u.id = $user_id AND p.id = $podcast_id \" \"MERGE (u)-[r:Rating{rating:toInteger($rating)}]->(p) \" ) tx . run ( query , user_id = user_id , podcast_id = podcast_id , rating = rating ) def create_user ( self , user_id : str ) -> None : \"\"\"Creates user Args: user_id (str): user id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_user , user_id ) @staticmethod def __create_user ( tx , user_id : str ) -> None : \"\"\"Helper for create_user Args: tx (_type_): transaction user_id (str): user id \"\"\" query = ( \"MERGE (u:User{id:$user_id}) \" ) tx . run ( query , user_id = user_id ) def create_podcast ( self , podcast_id : str , title : str ) -> None : \"\"\"Creates a podcast Args: podcast_id (str): podcast id title (str): title \"\"\" self . pod . loc [ len ( self . pod )] = [ podcast_id , title ] with self . driver . session () as sess : sess . write_transaction ( self . __create_podcast , podcast_id ) @staticmethod def __create_podcast ( tx , podcast_id : str ) -> None : \"\"\"Helper for create_podcast Args: tx (_type_): transaction podcast_id (str): podcast id \"\"\" query = ( \"MERGE (u:Podcast{id:$podcast_id}) \" ) tx . run ( query , podcast_id = podcast_id ) def create_category ( self , category : str , category_id : int ) -> None : \"\"\"Creates category Args: category (str): category name category_id (int): category id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_category , category , category_id ) @staticmethod def __create_category ( tx , category : str , category_id : int ) -> None : \"\"\"Helper for create_category Args: tx (_type_): transaction category (str): category name category_id (int): category id \"\"\" query = ( \"MERGE (u:Podcast{id:$category_id, name:$category}) \" ) tx . run ( query , category_id = category_id , category = category ) def create_IsA ( self , podcast_id : str , category : str ) -> None : \"\"\"Creates an IsA relationship Args: podcast_id (str): podcast id category (str): category name \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_IsA , podcast_id , category ) @staticmethod def __create_IsA ( tx , podcast_id : str , category : str ) -> None : \"\"\"Helper for create_IsA Args: tx (_type_): transaction podcast_id (str): podcast id category (str): category name \"\"\" query = ( \"MATCH (c:Category) MATCH (p:Podcast) \" \"WHERE c.name = $category AND p.id = $podcast_id \" \"MERGE (p)-[r:IsA]->(c) \" ) tx . run ( query , category = category , podcast_id = podcast_id ) def get_cat_based ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from paths (user)->(podcast)->(category)<-(podcast) Args: user_id (str): user id podcast_id (str): podcast id Returns: list: sum of ratings and count of paths \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __get_cat_based , user_id , podcast_id ) return result @staticmethod def __get_cat_based ( tx , user_id : str , podcast_id : str ) -> list : \"\"\"Helper for get_cat_based Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id Returns: list: sum of ratings and count of paths \"\"\" query = ( \"MATCH (u:User)-[r]->(Podcast)-->(Category)<--(p:Podcast) \" \"WHERE u.id = $user_id AND p.id = $podcast_id \" \"RETURN r\" ) result = tx . run ( query , user_id = user_id , podcast_id = podcast_id ) total = 0 cnt = 0 for rec in result : total += rec [ 'r' ][ 'rating' ] cnt += 1 return [ total , cnt ] def get_user_based ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from paths (user)->(podcast)<-(user)->(podcast) Args: user_id (str): user id podcast_id (str): podcast id Returns: list: sum of ratings and count of paths \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __get_user_based , user_id , podcast_id ) return result @staticmethod def __get_user_based ( tx , user_id : str , podcast_id : str ) -> list : \"\"\"Helper for get_user_based Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id Returns: list: sum of ratings and count of paths \"\"\" query = ( \"MATCH (u:User)-[r1]->(Podcast)<-[r2]->(User)-[r3]->(p:Podcast) \" \"WHERE u.id = $user_id AND p.id = $podcast_id \" \"RETURN r1.rating + r2.rating + r3.rating \" \"AS total\" ) result = tx . run ( query , user_id = user_id , podcast_id = podcast_id ) total = 0 cnt = 0 for rec in result : total += rec [ 'total' ] cnt += 1 return [ total , cnt ] def adamic_adar ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from Adamic Adar metric Args: user_id (str): user id podcast_id (str): podcast id Returns: list: adamic adar \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __adamic_adar , user_id , podcast_id ) return result @staticmethod def __adamic_adar ( tx , user_id : str , podcast_id : str ) -> list : \"\"\"Helper for adamic_adar Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id Returns: list: adamic adar \"\"\" query = ( \"MATCH (u:User)-[r]->(p1:Podcast) MATCH (p:Podcast)\" \"WHERE u.id = $user_id AND p.id = $podcast_id \" \"RETURN r.rating * gds.alpha.linkprediction.adamicAdar(p1, p) \" \"AS score \" ) result = tx . run ( query , user_id = user_id , podcast_id = podcast_id ) total = 0 for rec in result : total += rec [ 'score' ] return [ total ] def resource_allocation ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from resource allocation metric Args: user_id (str): user id podcast_id (str): podcast id Returns: list: resource allocation and count of paths \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __resource_allocation , user_id , podcast_id ) return result @staticmethod def __resource_allocation ( tx , user_id : str , podcast_id : str ) -> list : \"\"\"Helper for resource_allocation Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id Returns: list: resource allocation and count of paths \"\"\" query = ( \"MATCH (u:User)-[r]->(p1:Podcast) MATCH (p:Podcast)\" \"WHERE u.id = $user_id AND p.id = $podcast_id \" \"RETURN r.rating * gds.alpha.linkprediction.resourceAllocation(p1, p) \" \"AS score \" ) result = tx . run ( query , user_id = user_id , podcast_id = podcast_id ) total = 0 cnt = 0 for rec in result : total += rec [ 'score' ] cnt += 1 return [ total , cnt ] def gen_df ( self , user_id : str ) -> pd . DataFrame : \"\"\"Generates df with podcasts of interest Args: user_id (str): user id Returns: pd.DataFrame: dataframe with podcasts \"\"\" podcasts = self . gen_podcasts ( user_id ) df = pd . DataFrame ({ 'podcast_id' : podcasts }) if len ( df ) == 0 : pod = self . pod . copy () df = pod [ np . random . rand ( len ( pod )) < 0.2 ] df = df [ 'podcast_id' ] df = df . iloc [: 50 ,:] df [ 'user_id' ] = user_id return df . drop_duplicates () . reset_index () . iloc [: 50 , 1 :] def gen_podcasts ( self , user_id : str ) -> list : \"\"\"Helper for gen_df. Uses paths (user)-[*3]->(podcast) Args: user_id (str): user id Returns: list: list with podcasts \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __gen_podcasts , user_id ) return result @staticmethod def __gen_podcasts ( tx , user_id : str ) -> list : \"\"\"Helper for gen_podcasts Args: tx (): transaction user_id (str): user id Returns: list: podcasts \"\"\" query = ( \"MATCH (u:User)-[*3]-(p:Podcast) \" \"WHERE u.id = $user_id \" \"RETURN p.id AS p_id \" ) result = tx . run ( query , user_id = user_id ) ans = [] for rec in result : ans . append ( rec [ 'p_id' ]) return ans def delete_user ( self , user_id : str ) -> None : \"\"\"Deletes user Args: user_id (str): user id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_user , user_id ) @staticmethod def __delete_user ( tx , user_id : str ) -> None : \"\"\"Helper for delete_user Args: tx (_type_): transaction user_id (str): user id \"\"\" query = ( \"MATCH (u:User)-[r]->() WHERE u.id = $user_id \" \"DELETE r, u \" ) tx . run ( query , user_id = user_id ) def delete_podcast ( self , podcast_id : str ) -> None : \"\"\"Deletes podcast Args: podcast_id (str): podcast id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_podcast , podcast_id ) @staticmethod def __delete_podcast ( tx , podcast_id : str ) -> None : \"\"\"Helper for delete_podcast Args: tx (_type_): transaction podcast_id (str): podcast id \"\"\" query = ( \"MATCH (p:Podcast)-[r]-() WHERE p.id = $podcast_id \" \"DELETE r, p \" ) tx . run ( query , podcast_id = podcast_id ) def delete_cat ( self , category : str ) -> None : \"\"\"Deletes category Args: category (str): category name \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_cat , category ) @staticmethod def __delete_cat ( tx , category : str ) -> None : \"\"\"Helper for delete_cat Args: tx (_type_): transaction category (str): category name \"\"\" query = ( \"MATCH (c:Category)<-[r]-() WHERE c.name = $category \" \"DELETE r, c \" ) tx . run ( query , category = category ) def delete_IsA ( self , podcast_id : str , category : str ) -> None : \"\"\"Deletes IsA relationship Args: podcast_id (str): podcast id category (str): category name \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_IsA , podcast_id , category ) @staticmethod def __delete_IsA ( tx , podcast_id : str , category : str ) -> None : \"\"\"Helper for delete_IsA Args: tx (_type_): transaction podcast_id (str): podcast id category (str): category name \"\"\" query = ( \"MATCH (p:Podcast)-[r]->(c:Category) \" \"WHERE p.id = $podcast_id AND c.name = $category \" \"DELETE r\" ) tx . run ( query , podcast_id = podcast_id , category = category ) __init__ ( self , uri , auth , x_path = None , y_path = None , verbose = False ) special Creates object. Reads files to train Logistic Regression model. Parameters: uri ( str ) \u2013 neo4j uri auth ( str ) \u2013 neo4j (user, psw) x_path ( str ) \u2013 path to x_train. Defaults to X_PATH. y_path ( str ) \u2013 path to y_train. Defaults to Y_PATH. verbose ( bool ) \u2013 verbose. Defaults to False. Source code in podcast_recommendation/algorithm.py def __init__ ( self , uri : str , auth : str , x_path : str = None , y_path : str = None , verbose : bool = False ) -> None : \"\"\"Creates object. Reads files to train Logistic Regression model. Args: uri (str): neo4j uri auth (str): neo4j (user, psw) x_path (str, optional): path to x_train. Defaults to X_PATH. y_path (str, optional): path to y_train. Defaults to Y_PATH. verbose (bool, optional): verbose. Defaults to False. \"\"\" if x_path is None : x_path = X_PATH if y_path is None : y_path = Y_PATH self . driver = GD . driver ( uri , auth = auth ) self . features = [ 'cat_based' , 'cat_cnt' , 'user_based' , 'user_cnt' , 'adamic_adar' , 'resource_allocation' , 'link_cnt' , 'cat_avg' , 'user_avg' , 'adar_avg' , 'ra_avg' ] self . lr = LogisticRegression ( solver = 'liblinear' , C = 0.5 ) if verbose : print ( \"Reading x_train\" ) X = pd . read_csv ( x_path ) if verbose : print ( \"Reading y_train\" ) Y = pd . read_csv ( y_path ) if verbose : print ( \"Training model\" ) self . lr . fit ( X [ self . features ], Y . values . reshape ( 1 , - 1 )[ 0 ]) if verbose : print ( \"Training complete\" ) if verbose : print ( \"Reading podcasts\" ) self . pod = pd . read_csv ( POD_PATH ) adamic_adar ( self , user_id , podcast_id ) Generates data from Adamic Adar metric Parameters: user_id ( str ) \u2013 user id podcast_id ( str ) \u2013 podcast id Returns: list \u2013 adamic adar Source code in podcast_recommendation/algorithm.py def adamic_adar ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from Adamic Adar metric Args: user_id (str): user id podcast_id (str): podcast id Returns: list: adamic adar \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __adamic_adar , user_id , podcast_id ) return result build_cat ( self , row ) Builds relations in categories_sample dataset Parameters: row ( pd.Series ) \u2013 dataframe row Source code in podcast_recommendation/algorithm.py def build_cat ( self , row : pd . Series ) -> None : \"\"\"Builds relations in categories_sample dataset Args: row (pd.Series): dataframe row \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __build_cat , row [ 'category' ], row [ 'category_id' ], row [ 'podcast_id' ]) build_graph ( self , cat_path = None , rtg_path = None , delete_all = True , verbose = False ) Builds graph in neo4j Parameters: cat_path ( str ) \u2013 path to categories_sample. Defaults to CAT_PATH. rtg_path ( str ) \u2013 path to ratings_sample. Defaults to RTG_PATH. delete_all ( bool ) \u2013 if to delete graph before writting. Defaults to True. verbose ( bool ) \u2013 verbose. Defaults to False. Source code in podcast_recommendation/algorithm.py def build_graph ( self , cat_path : str = None , rtg_path : str = None , delete_all : bool = True , verbose : bool = False ) -> None : \"\"\"Builds graph in neo4j Args: cat_path (str, optional): path to categories_sample. Defaults to CAT_PATH. rtg_path (str, optional): path to ratings_sample. Defaults to RTG_PATH. delete_all (bool, optional): if to delete graph before writting. Defaults to True. verbose (bool, optional): verbose. Defaults to False. \"\"\" if cat_path is None : cat_path = CAT_PATH if rtg_path is None : rtg_path = RTG_PATH if delete_all : if verbose : print ( \"Deleting all nodes and relationships\" ) self . delete_all () if verbose : print ( \"Reading categories\" ) cat = pd . read_csv ( cat_path ) if verbose : print ( \"Reading ratings\" ) rtg = pd . read_csv ( rtg_path ) if verbose : print ( \"Creating podcasts, categories and IsA\" ) cat . apply ( self . build_cat , axis = 1 ) if verbose : print ( \"Creating users, categories and ratings\" ) rtg . apply ( self . build_rtg , axis = 1 ) if verbose : print ( \"Build complete\" ) build_rtg ( self , row ) Builds relations in ratings_sample dataset Parameters: row ( pd.Series ) \u2013 dataframe row Source code in podcast_recommendation/algorithm.py def build_rtg ( self , row : pd . Series ) -> None : \"\"\"Builds relations in ratings_sample dataset Args: row (pd.Series): dataframe row \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __build_rtg , row [ 'user_id' ], row [ 'podcast_id' ], row [ 'rating' ]) close ( self ) Closes driver. Source code in podcast_recommendation/algorithm.py def close ( self ) -> None : \"\"\"Closes driver. \"\"\" self . driver . close () create_IsA ( self , podcast_id , category ) Creates an IsA relationship Parameters: podcast_id ( str ) \u2013 podcast id category ( str ) \u2013 category name Source code in podcast_recommendation/algorithm.py def create_IsA ( self , podcast_id : str , category : str ) -> None : \"\"\"Creates an IsA relationship Args: podcast_id (str): podcast id category (str): category name \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_IsA , podcast_id , category ) create_category ( self , category , category_id ) Creates category Parameters: category ( str ) \u2013 category name category_id ( int ) \u2013 category id Source code in podcast_recommendation/algorithm.py def create_category ( self , category : str , category_id : int ) -> None : \"\"\"Creates category Args: category (str): category name category_id (int): category id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_category , category , category_id ) create_podcast ( self , podcast_id , title ) Creates a podcast Parameters: podcast_id ( str ) \u2013 podcast id title ( str ) \u2013 title Source code in podcast_recommendation/algorithm.py def create_podcast ( self , podcast_id : str , title : str ) -> None : \"\"\"Creates a podcast Args: podcast_id (str): podcast id title (str): title \"\"\" self . pod . loc [ len ( self . pod )] = [ podcast_id , title ] with self . driver . session () as sess : sess . write_transaction ( self . __create_podcast , podcast_id ) create_rtg ( self , user_id , podcast_id , rating ) Create rating relationship Parameters: user_id ( str ) \u2013 user id podcast_id ( str ) \u2013 podcast id rating ( int ) \u2013 rating Source code in podcast_recommendation/algorithm.py def create_rtg ( self , user_id : str , podcast_id : str , rating : int ) -> None : \"\"\"Create rating relationship Args: user_id (str): user id podcast_id (str): podcast id rating (int): rating \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_rtg , user_id , podcast_id , rating ) create_user ( self , user_id ) Creates user Parameters: user_id ( str ) \u2013 user id Source code in podcast_recommendation/algorithm.py def create_user ( self , user_id : str ) -> None : \"\"\"Creates user Args: user_id (str): user id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_user , user_id ) delete_IsA ( self , podcast_id , category ) Deletes IsA relationship Parameters: podcast_id ( str ) \u2013 podcast id category ( str ) \u2013 category name Source code in podcast_recommendation/algorithm.py def delete_IsA ( self , podcast_id : str , category : str ) -> None : \"\"\"Deletes IsA relationship Args: podcast_id (str): podcast id category (str): category name \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_IsA , podcast_id , category ) delete_all ( self ) Deletes all elements in the graph Source code in podcast_recommendation/algorithm.py def delete_all ( self ) -> None : \"\"\"Deletes all elements in the graph \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_all ) delete_cat ( self , category ) Deletes category Parameters: category ( str ) \u2013 category name Source code in podcast_recommendation/algorithm.py def delete_cat ( self , category : str ) -> None : \"\"\"Deletes category Args: category (str): category name \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_cat , category ) delete_podcast ( self , podcast_id ) Deletes podcast Parameters: podcast_id ( str ) \u2013 podcast id Source code in podcast_recommendation/algorithm.py def delete_podcast ( self , podcast_id : str ) -> None : \"\"\"Deletes podcast Args: podcast_id (str): podcast id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_podcast , podcast_id ) delete_rtg ( self , user_id , podcast_id ) Deletes rating relationship Parameters: user_id ( str ) \u2013 user id podcast_id ( str ) \u2013 podcast id Source code in podcast_recommendation/algorithm.py def delete_rtg ( self , user_id : str , podcast_id : str ) -> None : \"\"\"Deletes rating relationship Args: user_id (str): user id podcast_id (str): podcast id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_rtg , user_id , podcast_id ) delete_user ( self , user_id ) Deletes user Parameters: user_id ( str ) \u2013 user id Source code in podcast_recommendation/algorithm.py def delete_user ( self , user_id : str ) -> None : \"\"\"Deletes user Args: user_id (str): user id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_user , user_id ) gen_data ( self , df ) Generates data for podcast recommendation Parameters: df ( pd.DataFrame ) \u2013 podcasts Returns: pd.DataFrame \u2013 dataframe with attributes Source code in podcast_recommendation/algorithm.py def gen_data ( self , df : pd . DataFrame ) -> pd . DataFrame : \"\"\"Generates data for podcast recommendation Args: df (pd.DataFrame): podcasts Returns: pd.DataFrame: dataframe with attributes \"\"\" c_names = [ 'cat_based' , 'cat_cnt' , 'user_based' , 'user_cnt' , 'adamic_adar' , 'resource_allocation' , 'link_cnt' ] df [ c_names ] = df . apply ( self . gen_data_row , axis = 1 , result_type = 'expand' ) df [ 'cat_avg' ] = df [ 'cat_based' ] / df [ 'cat_cnt' ] df [ 'user_avg' ] = df [ 'user_based' ] / df [ 'user_cnt' ] df [ 'adar_avg' ] = df [ 'adamic_adar' ] / df [ 'link_cnt' ] df [ 'ra_avg' ] = df [ 'resource_allocation' ] / df [ 'link_cnt' ] df = df . fillna ( 0 ) return df gen_data_row ( self , row ) Helper for gen_data Parameters: row ( pd.Series ) \u2013 row of data Returns: list \u2013 list of attributes Source code in podcast_recommendation/algorithm.py def gen_data_row ( self , row : pd . Series ) -> list : \"\"\"Helper for gen_data Args: row (pd.Series): row of data Returns: list: list of attributes \"\"\" u_id , p_id = row [ 'user_id' ], row [ 'podcast_id' ] result = self . get_cat_based ( u_id , p_id ) result += self . get_user_based ( u_id , p_id ) result += self . adamic_adar ( u_id , p_id ) result += self . resource_allocation ( u_id , p_id ) return result gen_df ( self , user_id ) Generates df with podcasts of interest Parameters: user_id ( str ) \u2013 user id Returns: pd.DataFrame \u2013 dataframe with podcasts Source code in podcast_recommendation/algorithm.py def gen_df ( self , user_id : str ) -> pd . DataFrame : \"\"\"Generates df with podcasts of interest Args: user_id (str): user id Returns: pd.DataFrame: dataframe with podcasts \"\"\" podcasts = self . gen_podcasts ( user_id ) df = pd . DataFrame ({ 'podcast_id' : podcasts }) if len ( df ) == 0 : pod = self . pod . copy () df = pod [ np . random . rand ( len ( pod )) < 0.2 ] df = df [ 'podcast_id' ] df = df . iloc [: 50 ,:] df [ 'user_id' ] = user_id return df . drop_duplicates () . reset_index () . iloc [: 50 , 1 :] gen_podcasts ( self , user_id ) Helper for gen_df. Uses paths (user)-[*3]->(podcast) Parameters: user_id ( str ) \u2013 user id Returns: list \u2013 list with podcasts Source code in podcast_recommendation/algorithm.py def gen_podcasts ( self , user_id : str ) -> list : \"\"\"Helper for gen_df. Uses paths (user)-[*3]->(podcast) Args: user_id (str): user id Returns: list: list with podcasts \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __gen_podcasts , user_id ) return result get_cat_based ( self , user_id , podcast_id ) Generates data from paths (user)->(podcast)->(category)<-(podcast) Parameters: user_id ( str ) \u2013 user id podcast_id ( str ) \u2013 podcast id Returns: list \u2013 sum of ratings and count of paths Source code in podcast_recommendation/algorithm.py def get_cat_based ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from paths (user)->(podcast)->(category)<-(podcast) Args: user_id (str): user id podcast_id (str): podcast id Returns: list: sum of ratings and count of paths \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __get_cat_based , user_id , podcast_id ) return result get_user_based ( self , user_id , podcast_id ) Generates data from paths (user)->(podcast)<-(user)->(podcast) Parameters: user_id ( str ) \u2013 user id podcast_id ( str ) \u2013 podcast id Returns: list \u2013 sum of ratings and count of paths Source code in podcast_recommendation/algorithm.py def get_user_based ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from paths (user)->(podcast)<-(user)->(podcast) Args: user_id (str): user id podcast_id (str): podcast id Returns: list: sum of ratings and count of paths \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __get_user_based , user_id , podcast_id ) return result recommend ( self , user_id ) Generates podcast recommendation for user Parameters: user_id ( str ) \u2013 user id Returns: pd.DataFrame \u2013 podcasts and probabilities Source code in podcast_recommendation/algorithm.py def recommend ( self , user_id : str ) -> pd . DataFrame : \"\"\"Generates podcast recommendation for user Args: user_id (str): user id Returns: pd.DataFrame: podcasts and probabilities \"\"\" df = self . gen_df ( user_id ) df = self . gen_data ( df ) df [ 'proba' ] = self . lr . predict_proba ( df [ self . features ])[:, 1 ] df = df . sort_values ( by = 'proba' , ascending = False ) pod = self . pod . copy () . set_index ( 'podcast_id' ) df [ 'title' ] = df [ 'podcast_id' ] . map ( pod [ 'title' ]) return df [[ 'proba' , 'title' ]] resource_allocation ( self , user_id , podcast_id ) Generates data from resource allocation metric Parameters: user_id ( str ) \u2013 user id podcast_id ( str ) \u2013 podcast id Returns: list \u2013 resource allocation and count of paths Source code in podcast_recommendation/algorithm.py def resource_allocation ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from resource allocation metric Args: user_id (str): user id podcast_id (str): podcast id Returns: list: resource allocation and count of paths \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __resource_allocation , user_id , podcast_id ) return result","title":"Algorithm"},{"location":"algorithm-reference/#algorithm-module","text":"","title":"Algorithm module"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation","text":"Source code in podcast_recommendation/algorithm.py class PodcastRecommendation : def __init__ ( self , uri : str , auth : str , x_path : str = None , y_path : str = None , verbose : bool = False ) -> None : \"\"\"Creates object. Reads files to train Logistic Regression model. Args: uri (str): neo4j uri auth (str): neo4j (user, psw) x_path (str, optional): path to x_train. Defaults to X_PATH. y_path (str, optional): path to y_train. Defaults to Y_PATH. verbose (bool, optional): verbose. Defaults to False. \"\"\" if x_path is None : x_path = X_PATH if y_path is None : y_path = Y_PATH self . driver = GD . driver ( uri , auth = auth ) self . features = [ 'cat_based' , 'cat_cnt' , 'user_based' , 'user_cnt' , 'adamic_adar' , 'resource_allocation' , 'link_cnt' , 'cat_avg' , 'user_avg' , 'adar_avg' , 'ra_avg' ] self . lr = LogisticRegression ( solver = 'liblinear' , C = 0.5 ) if verbose : print ( \"Reading x_train\" ) X = pd . read_csv ( x_path ) if verbose : print ( \"Reading y_train\" ) Y = pd . read_csv ( y_path ) if verbose : print ( \"Training model\" ) self . lr . fit ( X [ self . features ], Y . values . reshape ( 1 , - 1 )[ 0 ]) if verbose : print ( \"Training complete\" ) if verbose : print ( \"Reading podcasts\" ) self . pod = pd . read_csv ( POD_PATH ) def build_graph ( self , cat_path : str = None , rtg_path : str = None , delete_all : bool = True , verbose : bool = False ) -> None : \"\"\"Builds graph in neo4j Args: cat_path (str, optional): path to categories_sample. Defaults to CAT_PATH. rtg_path (str, optional): path to ratings_sample. Defaults to RTG_PATH. delete_all (bool, optional): if to delete graph before writting. Defaults to True. verbose (bool, optional): verbose. Defaults to False. \"\"\" if cat_path is None : cat_path = CAT_PATH if rtg_path is None : rtg_path = RTG_PATH if delete_all : if verbose : print ( \"Deleting all nodes and relationships\" ) self . delete_all () if verbose : print ( \"Reading categories\" ) cat = pd . read_csv ( cat_path ) if verbose : print ( \"Reading ratings\" ) rtg = pd . read_csv ( rtg_path ) if verbose : print ( \"Creating podcasts, categories and IsA\" ) cat . apply ( self . build_cat , axis = 1 ) if verbose : print ( \"Creating users, categories and ratings\" ) rtg . apply ( self . build_rtg , axis = 1 ) if verbose : print ( \"Build complete\" ) def build_cat ( self , row : pd . Series ) -> None : \"\"\"Builds relations in categories_sample dataset Args: row (pd.Series): dataframe row \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __build_cat , row [ 'category' ], row [ 'category_id' ], row [ 'podcast_id' ]) @staticmethod def __build_cat ( tx , category : str , category_id : str , podcast_id : str ) -> None : \"\"\"Helper for build_cat Args: tx (_type_): transaction category (str): category name category_id (str): category id podcast_id (str): podcast id \"\"\" query = ( \"MERGE (p:Podcast{id: $podcast_id}) \" \"MERGE (c:Category{id: toInteger($category_id), name: $category}) \" \"MERGE (p)-[r:IsA]->(c) \" ) tx . run ( query , podcast_id = podcast_id , category_id = category_id , category = category ) def build_rtg ( self , row : pd . Series ) -> None : \"\"\"Builds relations in ratings_sample dataset Args: row (pd.Series): dataframe row \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __build_rtg , row [ 'user_id' ], row [ 'podcast_id' ], row [ 'rating' ]) @staticmethod def __build_rtg ( tx , user_id : str , podcast_id : str , rating : int ) -> None : \"\"\"Helper for build_rtg Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id rating (int): rating \"\"\" query = ( \"MERGE (u:User{id: $user_id}) \" \"MERGE (p:Podcast{id: $podcast_id}) \" \"MERGE (u)-[r:Rating{rating: toInteger($rating)}]->(p) \" ) tx . run ( query , user_id = user_id , podcast_id = podcast_id , rating = rating ) def close ( self ) -> None : \"\"\"Closes driver. \"\"\" self . driver . close () def delete_all ( self ) -> None : \"\"\"Deletes all elements in the graph \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_all ) @staticmethod def __delete_all ( tx ) -> None : \"\"\"Helper for delete all Args: tx (_type_): transaction \"\"\" query = \"MATCH (m)-[r]->(n) DELETE m, n, r\" tx . run ( query ) def recommend ( self , user_id : str ) -> pd . DataFrame : \"\"\"Generates podcast recommendation for user Args: user_id (str): user id Returns: pd.DataFrame: podcasts and probabilities \"\"\" df = self . gen_df ( user_id ) df = self . gen_data ( df ) df [ 'proba' ] = self . lr . predict_proba ( df [ self . features ])[:, 1 ] df = df . sort_values ( by = 'proba' , ascending = False ) pod = self . pod . copy () . set_index ( 'podcast_id' ) df [ 'title' ] = df [ 'podcast_id' ] . map ( pod [ 'title' ]) return df [[ 'proba' , 'title' ]] def gen_data ( self , df : pd . DataFrame ) -> pd . DataFrame : \"\"\"Generates data for podcast recommendation Args: df (pd.DataFrame): podcasts Returns: pd.DataFrame: dataframe with attributes \"\"\" c_names = [ 'cat_based' , 'cat_cnt' , 'user_based' , 'user_cnt' , 'adamic_adar' , 'resource_allocation' , 'link_cnt' ] df [ c_names ] = df . apply ( self . gen_data_row , axis = 1 , result_type = 'expand' ) df [ 'cat_avg' ] = df [ 'cat_based' ] / df [ 'cat_cnt' ] df [ 'user_avg' ] = df [ 'user_based' ] / df [ 'user_cnt' ] df [ 'adar_avg' ] = df [ 'adamic_adar' ] / df [ 'link_cnt' ] df [ 'ra_avg' ] = df [ 'resource_allocation' ] / df [ 'link_cnt' ] df = df . fillna ( 0 ) return df def gen_data_row ( self , row : pd . Series ) -> list : \"\"\"Helper for gen_data Args: row (pd.Series): row of data Returns: list: list of attributes \"\"\" u_id , p_id = row [ 'user_id' ], row [ 'podcast_id' ] result = self . get_cat_based ( u_id , p_id ) result += self . get_user_based ( u_id , p_id ) result += self . adamic_adar ( u_id , p_id ) result += self . resource_allocation ( u_id , p_id ) return result def delete_rtg ( self , user_id : str , podcast_id : str ) -> None : \"\"\"Deletes rating relationship Args: user_id (str): user id podcast_id (str): podcast id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_rtg , user_id , podcast_id ) @staticmethod def __delete_rtg ( tx , user_id : str , podcast_id : str ) -> None : \"\"\"Helper for delete_rtg Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id \"\"\" query = ( \"MATCH (u:User)-[r]->(p:Podcast) \" \"WHERE u.id = $user_id AND p.id = $podcast_id \" \"DELETE r\" ) tx . run ( query , user_id = user_id , podcast_id = podcast_id ) def create_rtg ( self , user_id : str , podcast_id : str , rating : int ) -> None : \"\"\"Create rating relationship Args: user_id (str): user id podcast_id (str): podcast id rating (int): rating \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_rtg , user_id , podcast_id , rating ) @staticmethod def __create_rtg ( tx , user_id : str , podcast_id : str , rating : int ) -> None : \"\"\"Helper for create_rtg Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id rating (int): rating \"\"\" query = ( \"MATCH (u:User) MATCH (p:Podcast) \" \"WHERE u.id = $user_id AND p.id = $podcast_id \" \"MERGE (u)-[r:Rating{rating:toInteger($rating)}]->(p) \" ) tx . run ( query , user_id = user_id , podcast_id = podcast_id , rating = rating ) def create_user ( self , user_id : str ) -> None : \"\"\"Creates user Args: user_id (str): user id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_user , user_id ) @staticmethod def __create_user ( tx , user_id : str ) -> None : \"\"\"Helper for create_user Args: tx (_type_): transaction user_id (str): user id \"\"\" query = ( \"MERGE (u:User{id:$user_id}) \" ) tx . run ( query , user_id = user_id ) def create_podcast ( self , podcast_id : str , title : str ) -> None : \"\"\"Creates a podcast Args: podcast_id (str): podcast id title (str): title \"\"\" self . pod . loc [ len ( self . pod )] = [ podcast_id , title ] with self . driver . session () as sess : sess . write_transaction ( self . __create_podcast , podcast_id ) @staticmethod def __create_podcast ( tx , podcast_id : str ) -> None : \"\"\"Helper for create_podcast Args: tx (_type_): transaction podcast_id (str): podcast id \"\"\" query = ( \"MERGE (u:Podcast{id:$podcast_id}) \" ) tx . run ( query , podcast_id = podcast_id ) def create_category ( self , category : str , category_id : int ) -> None : \"\"\"Creates category Args: category (str): category name category_id (int): category id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_category , category , category_id ) @staticmethod def __create_category ( tx , category : str , category_id : int ) -> None : \"\"\"Helper for create_category Args: tx (_type_): transaction category (str): category name category_id (int): category id \"\"\" query = ( \"MERGE (u:Podcast{id:$category_id, name:$category}) \" ) tx . run ( query , category_id = category_id , category = category ) def create_IsA ( self , podcast_id : str , category : str ) -> None : \"\"\"Creates an IsA relationship Args: podcast_id (str): podcast id category (str): category name \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_IsA , podcast_id , category ) @staticmethod def __create_IsA ( tx , podcast_id : str , category : str ) -> None : \"\"\"Helper for create_IsA Args: tx (_type_): transaction podcast_id (str): podcast id category (str): category name \"\"\" query = ( \"MATCH (c:Category) MATCH (p:Podcast) \" \"WHERE c.name = $category AND p.id = $podcast_id \" \"MERGE (p)-[r:IsA]->(c) \" ) tx . run ( query , category = category , podcast_id = podcast_id ) def get_cat_based ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from paths (user)->(podcast)->(category)<-(podcast) Args: user_id (str): user id podcast_id (str): podcast id Returns: list: sum of ratings and count of paths \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __get_cat_based , user_id , podcast_id ) return result @staticmethod def __get_cat_based ( tx , user_id : str , podcast_id : str ) -> list : \"\"\"Helper for get_cat_based Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id Returns: list: sum of ratings and count of paths \"\"\" query = ( \"MATCH (u:User)-[r]->(Podcast)-->(Category)<--(p:Podcast) \" \"WHERE u.id = $user_id AND p.id = $podcast_id \" \"RETURN r\" ) result = tx . run ( query , user_id = user_id , podcast_id = podcast_id ) total = 0 cnt = 0 for rec in result : total += rec [ 'r' ][ 'rating' ] cnt += 1 return [ total , cnt ] def get_user_based ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from paths (user)->(podcast)<-(user)->(podcast) Args: user_id (str): user id podcast_id (str): podcast id Returns: list: sum of ratings and count of paths \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __get_user_based , user_id , podcast_id ) return result @staticmethod def __get_user_based ( tx , user_id : str , podcast_id : str ) -> list : \"\"\"Helper for get_user_based Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id Returns: list: sum of ratings and count of paths \"\"\" query = ( \"MATCH (u:User)-[r1]->(Podcast)<-[r2]->(User)-[r3]->(p:Podcast) \" \"WHERE u.id = $user_id AND p.id = $podcast_id \" \"RETURN r1.rating + r2.rating + r3.rating \" \"AS total\" ) result = tx . run ( query , user_id = user_id , podcast_id = podcast_id ) total = 0 cnt = 0 for rec in result : total += rec [ 'total' ] cnt += 1 return [ total , cnt ] def adamic_adar ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from Adamic Adar metric Args: user_id (str): user id podcast_id (str): podcast id Returns: list: adamic adar \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __adamic_adar , user_id , podcast_id ) return result @staticmethod def __adamic_adar ( tx , user_id : str , podcast_id : str ) -> list : \"\"\"Helper for adamic_adar Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id Returns: list: adamic adar \"\"\" query = ( \"MATCH (u:User)-[r]->(p1:Podcast) MATCH (p:Podcast)\" \"WHERE u.id = $user_id AND p.id = $podcast_id \" \"RETURN r.rating * gds.alpha.linkprediction.adamicAdar(p1, p) \" \"AS score \" ) result = tx . run ( query , user_id = user_id , podcast_id = podcast_id ) total = 0 for rec in result : total += rec [ 'score' ] return [ total ] def resource_allocation ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from resource allocation metric Args: user_id (str): user id podcast_id (str): podcast id Returns: list: resource allocation and count of paths \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __resource_allocation , user_id , podcast_id ) return result @staticmethod def __resource_allocation ( tx , user_id : str , podcast_id : str ) -> list : \"\"\"Helper for resource_allocation Args: tx (_type_): transaction user_id (str): user id podcast_id (str): podcast id Returns: list: resource allocation and count of paths \"\"\" query = ( \"MATCH (u:User)-[r]->(p1:Podcast) MATCH (p:Podcast)\" \"WHERE u.id = $user_id AND p.id = $podcast_id \" \"RETURN r.rating * gds.alpha.linkprediction.resourceAllocation(p1, p) \" \"AS score \" ) result = tx . run ( query , user_id = user_id , podcast_id = podcast_id ) total = 0 cnt = 0 for rec in result : total += rec [ 'score' ] cnt += 1 return [ total , cnt ] def gen_df ( self , user_id : str ) -> pd . DataFrame : \"\"\"Generates df with podcasts of interest Args: user_id (str): user id Returns: pd.DataFrame: dataframe with podcasts \"\"\" podcasts = self . gen_podcasts ( user_id ) df = pd . DataFrame ({ 'podcast_id' : podcasts }) if len ( df ) == 0 : pod = self . pod . copy () df = pod [ np . random . rand ( len ( pod )) < 0.2 ] df = df [ 'podcast_id' ] df = df . iloc [: 50 ,:] df [ 'user_id' ] = user_id return df . drop_duplicates () . reset_index () . iloc [: 50 , 1 :] def gen_podcasts ( self , user_id : str ) -> list : \"\"\"Helper for gen_df. Uses paths (user)-[*3]->(podcast) Args: user_id (str): user id Returns: list: list with podcasts \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __gen_podcasts , user_id ) return result @staticmethod def __gen_podcasts ( tx , user_id : str ) -> list : \"\"\"Helper for gen_podcasts Args: tx (): transaction user_id (str): user id Returns: list: podcasts \"\"\" query = ( \"MATCH (u:User)-[*3]-(p:Podcast) \" \"WHERE u.id = $user_id \" \"RETURN p.id AS p_id \" ) result = tx . run ( query , user_id = user_id ) ans = [] for rec in result : ans . append ( rec [ 'p_id' ]) return ans def delete_user ( self , user_id : str ) -> None : \"\"\"Deletes user Args: user_id (str): user id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_user , user_id ) @staticmethod def __delete_user ( tx , user_id : str ) -> None : \"\"\"Helper for delete_user Args: tx (_type_): transaction user_id (str): user id \"\"\" query = ( \"MATCH (u:User)-[r]->() WHERE u.id = $user_id \" \"DELETE r, u \" ) tx . run ( query , user_id = user_id ) def delete_podcast ( self , podcast_id : str ) -> None : \"\"\"Deletes podcast Args: podcast_id (str): podcast id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_podcast , podcast_id ) @staticmethod def __delete_podcast ( tx , podcast_id : str ) -> None : \"\"\"Helper for delete_podcast Args: tx (_type_): transaction podcast_id (str): podcast id \"\"\" query = ( \"MATCH (p:Podcast)-[r]-() WHERE p.id = $podcast_id \" \"DELETE r, p \" ) tx . run ( query , podcast_id = podcast_id ) def delete_cat ( self , category : str ) -> None : \"\"\"Deletes category Args: category (str): category name \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_cat , category ) @staticmethod def __delete_cat ( tx , category : str ) -> None : \"\"\"Helper for delete_cat Args: tx (_type_): transaction category (str): category name \"\"\" query = ( \"MATCH (c:Category)<-[r]-() WHERE c.name = $category \" \"DELETE r, c \" ) tx . run ( query , category = category ) def delete_IsA ( self , podcast_id : str , category : str ) -> None : \"\"\"Deletes IsA relationship Args: podcast_id (str): podcast id category (str): category name \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_IsA , podcast_id , category ) @staticmethod def __delete_IsA ( tx , podcast_id : str , category : str ) -> None : \"\"\"Helper for delete_IsA Args: tx (_type_): transaction podcast_id (str): podcast id category (str): category name \"\"\" query = ( \"MATCH (p:Podcast)-[r]->(c:Category) \" \"WHERE p.id = $podcast_id AND c.name = $category \" \"DELETE r\" ) tx . run ( query , podcast_id = podcast_id , category = category )","title":"PodcastRecommendation"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.__init__","text":"Creates object. Reads files to train Logistic Regression model. Parameters: uri ( str ) \u2013 neo4j uri auth ( str ) \u2013 neo4j (user, psw) x_path ( str ) \u2013 path to x_train. Defaults to X_PATH. y_path ( str ) \u2013 path to y_train. Defaults to Y_PATH. verbose ( bool ) \u2013 verbose. Defaults to False. Source code in podcast_recommendation/algorithm.py def __init__ ( self , uri : str , auth : str , x_path : str = None , y_path : str = None , verbose : bool = False ) -> None : \"\"\"Creates object. Reads files to train Logistic Regression model. Args: uri (str): neo4j uri auth (str): neo4j (user, psw) x_path (str, optional): path to x_train. Defaults to X_PATH. y_path (str, optional): path to y_train. Defaults to Y_PATH. verbose (bool, optional): verbose. Defaults to False. \"\"\" if x_path is None : x_path = X_PATH if y_path is None : y_path = Y_PATH self . driver = GD . driver ( uri , auth = auth ) self . features = [ 'cat_based' , 'cat_cnt' , 'user_based' , 'user_cnt' , 'adamic_adar' , 'resource_allocation' , 'link_cnt' , 'cat_avg' , 'user_avg' , 'adar_avg' , 'ra_avg' ] self . lr = LogisticRegression ( solver = 'liblinear' , C = 0.5 ) if verbose : print ( \"Reading x_train\" ) X = pd . read_csv ( x_path ) if verbose : print ( \"Reading y_train\" ) Y = pd . read_csv ( y_path ) if verbose : print ( \"Training model\" ) self . lr . fit ( X [ self . features ], Y . values . reshape ( 1 , - 1 )[ 0 ]) if verbose : print ( \"Training complete\" ) if verbose : print ( \"Reading podcasts\" ) self . pod = pd . read_csv ( POD_PATH )","title":"__init__()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.adamic_adar","text":"Generates data from Adamic Adar metric Parameters: user_id ( str ) \u2013 user id podcast_id ( str ) \u2013 podcast id Returns: list \u2013 adamic adar Source code in podcast_recommendation/algorithm.py def adamic_adar ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from Adamic Adar metric Args: user_id (str): user id podcast_id (str): podcast id Returns: list: adamic adar \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __adamic_adar , user_id , podcast_id ) return result","title":"adamic_adar()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.build_cat","text":"Builds relations in categories_sample dataset Parameters: row ( pd.Series ) \u2013 dataframe row Source code in podcast_recommendation/algorithm.py def build_cat ( self , row : pd . Series ) -> None : \"\"\"Builds relations in categories_sample dataset Args: row (pd.Series): dataframe row \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __build_cat , row [ 'category' ], row [ 'category_id' ], row [ 'podcast_id' ])","title":"build_cat()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.build_graph","text":"Builds graph in neo4j Parameters: cat_path ( str ) \u2013 path to categories_sample. Defaults to CAT_PATH. rtg_path ( str ) \u2013 path to ratings_sample. Defaults to RTG_PATH. delete_all ( bool ) \u2013 if to delete graph before writting. Defaults to True. verbose ( bool ) \u2013 verbose. Defaults to False. Source code in podcast_recommendation/algorithm.py def build_graph ( self , cat_path : str = None , rtg_path : str = None , delete_all : bool = True , verbose : bool = False ) -> None : \"\"\"Builds graph in neo4j Args: cat_path (str, optional): path to categories_sample. Defaults to CAT_PATH. rtg_path (str, optional): path to ratings_sample. Defaults to RTG_PATH. delete_all (bool, optional): if to delete graph before writting. Defaults to True. verbose (bool, optional): verbose. Defaults to False. \"\"\" if cat_path is None : cat_path = CAT_PATH if rtg_path is None : rtg_path = RTG_PATH if delete_all : if verbose : print ( \"Deleting all nodes and relationships\" ) self . delete_all () if verbose : print ( \"Reading categories\" ) cat = pd . read_csv ( cat_path ) if verbose : print ( \"Reading ratings\" ) rtg = pd . read_csv ( rtg_path ) if verbose : print ( \"Creating podcasts, categories and IsA\" ) cat . apply ( self . build_cat , axis = 1 ) if verbose : print ( \"Creating users, categories and ratings\" ) rtg . apply ( self . build_rtg , axis = 1 ) if verbose : print ( \"Build complete\" )","title":"build_graph()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.build_rtg","text":"Builds relations in ratings_sample dataset Parameters: row ( pd.Series ) \u2013 dataframe row Source code in podcast_recommendation/algorithm.py def build_rtg ( self , row : pd . Series ) -> None : \"\"\"Builds relations in ratings_sample dataset Args: row (pd.Series): dataframe row \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __build_rtg , row [ 'user_id' ], row [ 'podcast_id' ], row [ 'rating' ])","title":"build_rtg()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.close","text":"Closes driver. Source code in podcast_recommendation/algorithm.py def close ( self ) -> None : \"\"\"Closes driver. \"\"\" self . driver . close ()","title":"close()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.create_IsA","text":"Creates an IsA relationship Parameters: podcast_id ( str ) \u2013 podcast id category ( str ) \u2013 category name Source code in podcast_recommendation/algorithm.py def create_IsA ( self , podcast_id : str , category : str ) -> None : \"\"\"Creates an IsA relationship Args: podcast_id (str): podcast id category (str): category name \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_IsA , podcast_id , category )","title":"create_IsA()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.create_category","text":"Creates category Parameters: category ( str ) \u2013 category name category_id ( int ) \u2013 category id Source code in podcast_recommendation/algorithm.py def create_category ( self , category : str , category_id : int ) -> None : \"\"\"Creates category Args: category (str): category name category_id (int): category id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_category , category , category_id )","title":"create_category()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.create_podcast","text":"Creates a podcast Parameters: podcast_id ( str ) \u2013 podcast id title ( str ) \u2013 title Source code in podcast_recommendation/algorithm.py def create_podcast ( self , podcast_id : str , title : str ) -> None : \"\"\"Creates a podcast Args: podcast_id (str): podcast id title (str): title \"\"\" self . pod . loc [ len ( self . pod )] = [ podcast_id , title ] with self . driver . session () as sess : sess . write_transaction ( self . __create_podcast , podcast_id )","title":"create_podcast()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.create_rtg","text":"Create rating relationship Parameters: user_id ( str ) \u2013 user id podcast_id ( str ) \u2013 podcast id rating ( int ) \u2013 rating Source code in podcast_recommendation/algorithm.py def create_rtg ( self , user_id : str , podcast_id : str , rating : int ) -> None : \"\"\"Create rating relationship Args: user_id (str): user id podcast_id (str): podcast id rating (int): rating \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_rtg , user_id , podcast_id , rating )","title":"create_rtg()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.create_user","text":"Creates user Parameters: user_id ( str ) \u2013 user id Source code in podcast_recommendation/algorithm.py def create_user ( self , user_id : str ) -> None : \"\"\"Creates user Args: user_id (str): user id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __create_user , user_id )","title":"create_user()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.delete_IsA","text":"Deletes IsA relationship Parameters: podcast_id ( str ) \u2013 podcast id category ( str ) \u2013 category name Source code in podcast_recommendation/algorithm.py def delete_IsA ( self , podcast_id : str , category : str ) -> None : \"\"\"Deletes IsA relationship Args: podcast_id (str): podcast id category (str): category name \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_IsA , podcast_id , category )","title":"delete_IsA()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.delete_all","text":"Deletes all elements in the graph Source code in podcast_recommendation/algorithm.py def delete_all ( self ) -> None : \"\"\"Deletes all elements in the graph \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_all )","title":"delete_all()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.delete_cat","text":"Deletes category Parameters: category ( str ) \u2013 category name Source code in podcast_recommendation/algorithm.py def delete_cat ( self , category : str ) -> None : \"\"\"Deletes category Args: category (str): category name \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_cat , category )","title":"delete_cat()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.delete_podcast","text":"Deletes podcast Parameters: podcast_id ( str ) \u2013 podcast id Source code in podcast_recommendation/algorithm.py def delete_podcast ( self , podcast_id : str ) -> None : \"\"\"Deletes podcast Args: podcast_id (str): podcast id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_podcast , podcast_id )","title":"delete_podcast()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.delete_rtg","text":"Deletes rating relationship Parameters: user_id ( str ) \u2013 user id podcast_id ( str ) \u2013 podcast id Source code in podcast_recommendation/algorithm.py def delete_rtg ( self , user_id : str , podcast_id : str ) -> None : \"\"\"Deletes rating relationship Args: user_id (str): user id podcast_id (str): podcast id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_rtg , user_id , podcast_id )","title":"delete_rtg()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.delete_user","text":"Deletes user Parameters: user_id ( str ) \u2013 user id Source code in podcast_recommendation/algorithm.py def delete_user ( self , user_id : str ) -> None : \"\"\"Deletes user Args: user_id (str): user id \"\"\" with self . driver . session () as sess : sess . write_transaction ( self . __delete_user , user_id )","title":"delete_user()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.gen_data","text":"Generates data for podcast recommendation Parameters: df ( pd.DataFrame ) \u2013 podcasts Returns: pd.DataFrame \u2013 dataframe with attributes Source code in podcast_recommendation/algorithm.py def gen_data ( self , df : pd . DataFrame ) -> pd . DataFrame : \"\"\"Generates data for podcast recommendation Args: df (pd.DataFrame): podcasts Returns: pd.DataFrame: dataframe with attributes \"\"\" c_names = [ 'cat_based' , 'cat_cnt' , 'user_based' , 'user_cnt' , 'adamic_adar' , 'resource_allocation' , 'link_cnt' ] df [ c_names ] = df . apply ( self . gen_data_row , axis = 1 , result_type = 'expand' ) df [ 'cat_avg' ] = df [ 'cat_based' ] / df [ 'cat_cnt' ] df [ 'user_avg' ] = df [ 'user_based' ] / df [ 'user_cnt' ] df [ 'adar_avg' ] = df [ 'adamic_adar' ] / df [ 'link_cnt' ] df [ 'ra_avg' ] = df [ 'resource_allocation' ] / df [ 'link_cnt' ] df = df . fillna ( 0 ) return df","title":"gen_data()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.gen_data_row","text":"Helper for gen_data Parameters: row ( pd.Series ) \u2013 row of data Returns: list \u2013 list of attributes Source code in podcast_recommendation/algorithm.py def gen_data_row ( self , row : pd . Series ) -> list : \"\"\"Helper for gen_data Args: row (pd.Series): row of data Returns: list: list of attributes \"\"\" u_id , p_id = row [ 'user_id' ], row [ 'podcast_id' ] result = self . get_cat_based ( u_id , p_id ) result += self . get_user_based ( u_id , p_id ) result += self . adamic_adar ( u_id , p_id ) result += self . resource_allocation ( u_id , p_id ) return result","title":"gen_data_row()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.gen_df","text":"Generates df with podcasts of interest Parameters: user_id ( str ) \u2013 user id Returns: pd.DataFrame \u2013 dataframe with podcasts Source code in podcast_recommendation/algorithm.py def gen_df ( self , user_id : str ) -> pd . DataFrame : \"\"\"Generates df with podcasts of interest Args: user_id (str): user id Returns: pd.DataFrame: dataframe with podcasts \"\"\" podcasts = self . gen_podcasts ( user_id ) df = pd . DataFrame ({ 'podcast_id' : podcasts }) if len ( df ) == 0 : pod = self . pod . copy () df = pod [ np . random . rand ( len ( pod )) < 0.2 ] df = df [ 'podcast_id' ] df = df . iloc [: 50 ,:] df [ 'user_id' ] = user_id return df . drop_duplicates () . reset_index () . iloc [: 50 , 1 :]","title":"gen_df()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.gen_podcasts","text":"Helper for gen_df. Uses paths (user)-[*3]->(podcast) Parameters: user_id ( str ) \u2013 user id Returns: list \u2013 list with podcasts Source code in podcast_recommendation/algorithm.py def gen_podcasts ( self , user_id : str ) -> list : \"\"\"Helper for gen_df. Uses paths (user)-[*3]->(podcast) Args: user_id (str): user id Returns: list: list with podcasts \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __gen_podcasts , user_id ) return result","title":"gen_podcasts()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.get_cat_based","text":"Generates data from paths (user)->(podcast)->(category)<-(podcast) Parameters: user_id ( str ) \u2013 user id podcast_id ( str ) \u2013 podcast id Returns: list \u2013 sum of ratings and count of paths Source code in podcast_recommendation/algorithm.py def get_cat_based ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from paths (user)->(podcast)->(category)<-(podcast) Args: user_id (str): user id podcast_id (str): podcast id Returns: list: sum of ratings and count of paths \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __get_cat_based , user_id , podcast_id ) return result","title":"get_cat_based()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.get_user_based","text":"Generates data from paths (user)->(podcast)<-(user)->(podcast) Parameters: user_id ( str ) \u2013 user id podcast_id ( str ) \u2013 podcast id Returns: list \u2013 sum of ratings and count of paths Source code in podcast_recommendation/algorithm.py def get_user_based ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from paths (user)->(podcast)<-(user)->(podcast) Args: user_id (str): user id podcast_id (str): podcast id Returns: list: sum of ratings and count of paths \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __get_user_based , user_id , podcast_id ) return result","title":"get_user_based()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.recommend","text":"Generates podcast recommendation for user Parameters: user_id ( str ) \u2013 user id Returns: pd.DataFrame \u2013 podcasts and probabilities Source code in podcast_recommendation/algorithm.py def recommend ( self , user_id : str ) -> pd . DataFrame : \"\"\"Generates podcast recommendation for user Args: user_id (str): user id Returns: pd.DataFrame: podcasts and probabilities \"\"\" df = self . gen_df ( user_id ) df = self . gen_data ( df ) df [ 'proba' ] = self . lr . predict_proba ( df [ self . features ])[:, 1 ] df = df . sort_values ( by = 'proba' , ascending = False ) pod = self . pod . copy () . set_index ( 'podcast_id' ) df [ 'title' ] = df [ 'podcast_id' ] . map ( pod [ 'title' ]) return df [[ 'proba' , 'title' ]]","title":"recommend()"},{"location":"algorithm-reference/#src.podcast_recommendation.algorithm.PodcastRecommendation.resource_allocation","text":"Generates data from resource allocation metric Parameters: user_id ( str ) \u2013 user id podcast_id ( str ) \u2013 podcast id Returns: list \u2013 resource allocation and count of paths Source code in podcast_recommendation/algorithm.py def resource_allocation ( self , user_id : str , podcast_id : str ) -> list : \"\"\"Generates data from resource allocation metric Args: user_id (str): user id podcast_id (str): podcast id Returns: list: resource allocation and count of paths \"\"\" with self . driver . session () as sess : result = sess . write_transaction ( self . __resource_allocation , user_id , podcast_id ) return result","title":"resource_allocation()"},{"location":"database/","text":"Base de Datos La base de datos consiste de 3 tablas principales y 2 tablas con atributos de entrenamiento. Tablas Principales Las tablas principales son: categories.sample.csv podcast_sample_title.csv ratings_sample.csv Categories Sample La tabla consta de 3 columnas: podcast_id: id para el podcast category: nombre de la categoria category_id: id de la categoria Esta tabla es utilizada para generar las relaciones IsA en Neo4j. Acceder archivo Podcast Sample Title La tabla consta de 2 columnas: podcast_id: id del podcast title: t\u00edtulo del podcast La tabla es utilizada para mostrar los t\u00edtulos en las recomendaciones. Acceder archivo Ratings Sample La tabla consta de 4 columnas: podcast_id: id del podcast evaluado user_id: id del usuario realizando la evaluaci\u00f3n rating: rating del podcast entre 1 y 5 liked: si rating es mayor a 2 o no Esta tabla es utilizada para generar las relaciones Rating en Neo4j. Acceder archivo Tablas de entrenamiento Las tablas de entrenamiento son: x_train.csv y_train.csv X Train La tabla consta de 13 columnas: podcast_id: id del podcast user_id: id del usuario cat_based: suma de ratings obtenidos en paths de la forma (User)->(Podcast)<-(Category)->(Podcast) cat_cnt: cuenta de paths de la forma (User)->(Podcast)->(Category)<-(Podcast) user_based: suma de ratings obtenidos en paths de la forma (User)->(Podcast)<-(User)->(Podcast) user_cnt: cuenta de paths de la forma (User)->(Podcast)<-(User)->(Podcast) adamic_adar: multiplicaci\u00f3n de rating con la m\u00e9trica Adamic Adar entre podcasts de la forma (User)->(Podcast)--()--(Podcast) resource_allocation: multiplicaci\u00f3n de rating con la m\u00e9trica Resource Allocation entre podcasts de la forma (User)->(Podcast)--()--(Podcast) link_cnt: cuenta de paths de la forma (User)->(Podcast)--()--(Podcast) cat_avg: cat_based dividido entre cat_cnt user_avg: user_based dividido entre user_cnt adar: adamic_adar dividido entre link_cnt ra_avg: resource_allocation dividido entre link_cnt Esta tabla es utilzada para entrenar el modelo de regresi\u00f3n log\u00edstica Acceder archivo Y train Esta tabla contiene una \u00fanica columna: liked: si el rating es mayor o igual a 3 Esta tabla es el objetivo del entrenamiento del modelo Acceder archivo","title":"Database"},{"location":"database/#base-de-datos","text":"La base de datos consiste de 3 tablas principales y 2 tablas con atributos de entrenamiento.","title":"Base de Datos"},{"location":"database/#tablas-principales","text":"Las tablas principales son: categories.sample.csv podcast_sample_title.csv ratings_sample.csv","title":"Tablas Principales"},{"location":"database/#categories-sample","text":"La tabla consta de 3 columnas: podcast_id: id para el podcast category: nombre de la categoria category_id: id de la categoria Esta tabla es utilizada para generar las relaciones IsA en Neo4j. Acceder archivo","title":"Categories Sample"},{"location":"database/#podcast-sample-title","text":"La tabla consta de 2 columnas: podcast_id: id del podcast title: t\u00edtulo del podcast La tabla es utilizada para mostrar los t\u00edtulos en las recomendaciones. Acceder archivo","title":"Podcast Sample Title"},{"location":"database/#ratings-sample","text":"La tabla consta de 4 columnas: podcast_id: id del podcast evaluado user_id: id del usuario realizando la evaluaci\u00f3n rating: rating del podcast entre 1 y 5 liked: si rating es mayor a 2 o no Esta tabla es utilizada para generar las relaciones Rating en Neo4j. Acceder archivo","title":"Ratings Sample"},{"location":"database/#tablas-de-entrenamiento","text":"Las tablas de entrenamiento son: x_train.csv y_train.csv","title":"Tablas de entrenamiento"},{"location":"database/#x-train","text":"La tabla consta de 13 columnas: podcast_id: id del podcast user_id: id del usuario cat_based: suma de ratings obtenidos en paths de la forma (User)->(Podcast)<-(Category)->(Podcast) cat_cnt: cuenta de paths de la forma (User)->(Podcast)->(Category)<-(Podcast) user_based: suma de ratings obtenidos en paths de la forma (User)->(Podcast)<-(User)->(Podcast) user_cnt: cuenta de paths de la forma (User)->(Podcast)<-(User)->(Podcast) adamic_adar: multiplicaci\u00f3n de rating con la m\u00e9trica Adamic Adar entre podcasts de la forma (User)->(Podcast)--()--(Podcast) resource_allocation: multiplicaci\u00f3n de rating con la m\u00e9trica Resource Allocation entre podcasts de la forma (User)->(Podcast)--()--(Podcast) link_cnt: cuenta de paths de la forma (User)->(Podcast)--()--(Podcast) cat_avg: cat_based dividido entre cat_cnt user_avg: user_based dividido entre user_cnt adar: adamic_adar dividido entre link_cnt ra_avg: resource_allocation dividido entre link_cnt Esta tabla es utilzada para entrenar el modelo de regresi\u00f3n log\u00edstica Acceder archivo","title":"X Train"},{"location":"database/#y-train","text":"Esta tabla contiene una \u00fanica columna: liked: si el rating es mayor o igual a 3 Esta tabla es el objetivo del entrenamiento del modelo Acceder archivo","title":"Y train"}]}